//-----------------------------------------------------------------------------
// File: GlobalMemoryMapHeaderWriter.cpp
//-----------------------------------------------------------------------------
// Project: Kactus 2
// Author: Mikko Teuho
// Date: 08.05.2015
//
// Description:
// The implementation for creating c-headers of global memory maps.
//-----------------------------------------------------------------------------

#include "GlobalMemoryMapHeaderWriter.h"

#include <KactusAPI/include/LibraryInterface.h>
#include <KactusAPI/include/IPluginUtility.h>
#include <KactusAPI/include/ListParameterFinder.h>

#include <editors/MemoryDesigner/MemoryItem.h>
#include <editors/MemoryDesigner/MemoryDesignerConstants.h>

#include <Plugins/common/ConnectivityGraphUtilities.h>
#include <Plugins/MemoryMapHeaderGenerator/fileSaveDialog/filesavedialog.h>

#include <IPXACTmodels/Component/BusInterface.h>
#include <IPXACTmodels/Component/Channel.h>
#include <IPXACTmodels/Component/InitiatorInterface.h>
#include <IPXACTmodels/Component/MirroredTargetInterface.h>
#include <IPXACTmodels/Component/TargetInterface.h>

#include <QDate>
#include <QDir>
#include <QDesktopServices>

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::GlobalMemoryMapHeaderWriter()
//-----------------------------------------------------------------------------
GlobalMemoryMapHeaderWriter::GlobalMemoryMapHeaderWriter(IPluginUtility* utility,
    QSharedPointer<Design> componentDesign, QSharedPointer<DesignConfiguration> componentDesignConfig,
    QObject* parentObject):
BaseMemoryMapHeaderWriter(utility),
parentObject_(parentObject),
componentDesign_(componentDesign),
componentDesignConfig_(componentDesignConfig),
operatedInterfaces_(),
saveOptions_()
{

}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::GlobalMemoryMapHeaderWriter()
//-----------------------------------------------------------------------------
GlobalMemoryMapHeaderWriter::~GlobalMemoryMapHeaderWriter()
{

}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::writeMemoryMapHeader()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::writeMemoryMapHeader(QSharedPointer<Component> globalComponent,
    QList<QSharedPointer<GlobalHeaderSaveModel::SaveFileOptions> > saveOptions)
{
    auto viewName = ConnectivityGraphUtilities::getDesignViewName(globalComponent, componentDesign_, componentDesignConfig_);
    auto defaultCPUs = ConnectivityGraphUtilities::getDefaultCPUs(utility_->getLibraryInterface(), globalComponent, viewName);

    saveOptions_ = saveOptions;
    QList<QSharedPointer<GlobalHeaderSaveModel::SaveFileOptions> > options = saveOptions_;

    bool changed = false;

    GlobalHeaderSaveModel model(utility_->getLibraryInterface(), parentObject_);
    model.setCPUData(globalComponent, defaultCPUs);

    if (options.isEmpty())
    {
        // create the dialog to display the headers to be generated
        FileSaveDialog dialog(utility_->getParentWidget());
        dialog.setModel(&model);

        // if user clicked cancel
		if (dialog.exec() == QDialog::Rejected)
        {
            informGenerationAbort();
            return;
        }

        options = model.getHeaderOptions();
    }
    else
    {
        setupRoutesForExistingOptions(options, defaultCPUs);
    }

    informStartOfGeneration();

	for(auto headerOpt : options)
    {
		QFile file(headerOpt->fileInfo_.absoluteFilePath());

        checkDirectoryStructure(headerOpt->fileInfo_.dir());

		if (!file.open(QFile::Truncate | QFile::WriteOnly))
        {
            openFileErrorMessage(headerOpt->fileInfo_.absoluteFilePath());
			break;
		}

		QTextStream stream(&file);

        QString description (" * Header file generated by Kactus2 for instance \"" + headerOpt->instance_ +
            "\" interface \"" + headerOpt->interface_ + "\".\n"+
            " * This file contains addresses of the memories and registers defined in the memory maps " +
            "of connected components.\n" +
            " * Source component: " + headerOpt->comp_.toString() + ".\n" +
        	"*/\n");

        QString headerGuard ("__" + headerOpt->instance_.toUpper() + "_" + headerOpt->interface_.toUpper() + "_H");

        writeTopOfHeaderFile(stream, headerOpt->fileInfo_.fileName(), headerGuard, description);

        parseRoutes(stream, headerOpt->cpuContainer_);

		stream << "#endif /* " << headerGuard << " */" << Qt::endl << Qt::endl;

        file.close();

        informWritingFinished(headerOpt->fileInfo_.fileName());

		addHeaderFile(globalComponent, headerOpt->fileInfo_, headerOpt->instance_, QStringList(),
            headerOpt->instanceId_);

		// a header file was added
		changed = true;

		// the list must be cleared when moving to completely new master interface so each header generation
        // starts from scratch.
		operatedInterfaces_.clear();
	}

	if (changed)
    {
		// save the changes to the file sets
		utility_->getLibraryInterface()->writeModelToFile(globalComponent);
	}

	// clear the members for next generation run
    componentDesign_.clear();
	operatedInterfaces_.clear();


    informGenerationComplete();
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::setupRoutesForExistingOptions()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::setupRoutesForExistingOptions(
    QList<QSharedPointer<GlobalHeaderSaveModel::SaveFileOptions> > options,
    QVector<QSharedPointer<SingleCpuRoutesContainer> > cpuRoutes)
{
    for (auto singleCPU : cpuRoutes)
    {
        if (auto matchingOption = getSaveOptionForCPU(options, singleCPU); matchingOption)
        {
			matchingOption->cpuContainer_ = singleCPU;
        }
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::getSaveOptionForCPU()
//-----------------------------------------------------------------------------
QSharedPointer<GlobalHeaderSaveModel::SaveFileOptions> GlobalMemoryMapHeaderWriter::getSaveOptionForCPU(
    QList<QSharedPointer<GlobalHeaderSaveModel::SaveFileOptions> > options,
    QSharedPointer<SingleCpuRoutesContainer> singleCPU)
{
    auto cpuInterface = singleCPU->getRoutes().first()->cpuInterface_;
    auto cpuInstance = cpuInterface->getInstance();
    
    auto interfaceName = cpuInterface->getName();
    auto instanceName = cpuInstance->getName();
    
    VLNV cpuComponentVLNV(VLNV::COMPONENT, cpuInstance->getVlnv());

    for (auto saveOption : options)
    {
        if (saveOption->instance_ == instanceName &&
            saveOption->interface_ == interfaceName &&
            saveOption->comp_ == cpuComponentVLNV &&
            saveOption->instanceId_ == cpuInstance->getInstanceUuid())
        {
            return saveOption;
        }
    }

    return QSharedPointer<GlobalHeaderSaveModel::SaveFileOptions>();
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseRoutes()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseRoutes(QTextStream& stream, QSharedPointer<SingleCpuRoutesContainer> container)
{
    if (!container)
    {
        return;
    }

    for (auto const& startingInterfaceRoutes : container->getRoutes())
    {
        for (auto const& interfaceRoutes : startingInterfaceRoutes->routes_)
        {
            AddressContainer addressContainer;

            //! A single route starts in here
            for (auto currentInterface : interfaceRoutes)
            {
                auto interfaceMode = currentInterface->getMode();
				if (interfaceMode == General::MASTER || interfaceMode == General::INITIATOR)
				{
					parseMasterInterface(addressContainer, currentInterface);
				}
				else if (interfaceMode == General::SLAVE || interfaceMode == General::TARGET)
				{
					parseTargetInterface(addressContainer, stream, currentInterface);
				}
				else if (interfaceMode == General::MIRRORED_SLAVE || interfaceMode == General::MIRRORED_TARGET)
				{
					parseMirroredTargetInterface(addressContainer, currentInterface);
				}
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseMasterInterface()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseMasterInterface(AddressContainer& addressContainer, QSharedPointer<const ConnectivityInterface> masterInterface) const
{
    addressContainer.baseAddress_ += masterInterface->getBaseAddress().toULongLong();
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseTargetInterface()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseTargetInterface(AddressContainer addressContainer,
    QTextStream& stream,
    QSharedPointer<const ConnectivityInterface> targetInterface)
{
	auto memoryItem = targetInterface->getConnectedMemory();
    if (targetInterface->isBridged() || !memoryItem)
    {
        return;
    }

	if (memoryItem->getType() == MemoryDesignerConstants::MEMORYMAP_TYPE && memoryItemContainsAddressBlocks(memoryItem))
    {
        auto targetInstance = targetInterface->getInstance();

        stream << "/*" << Qt::endl;
		stream << " * Instance: " << targetInstance->getName() << " Interface: " << targetInterface->getName() << Qt::endl;
		stream << " * Instance base address: 0x" << QString::number(addressContainer.baseAddress_, 16) << Qt::endl;
		stream << " * Source component: " << targetInstance->getVlnv() << Qt::endl;

        // if there is a description for the component instance
        auto instanceDescription = targetInstance->getDescription();
        if (!instanceDescription.isEmpty())
        {
            stream << " * Description:" << Qt::endl;
            stream << " * " << instanceDescription << Qt::endl;
        }

		stream << " * The defines for the memory map \"" << memoryItem->getName() << "\":" << Qt::endl;
        stream << "*/" << Qt::endl << Qt::endl;

        writeMemoryAddresses(addressContainer, stream, memoryItem, targetInstance->getName());

        // if the registers within the instance are unique then do not concatenate with address block name
        /*QStringList regNames;
        if (memMap->uniqueRegisterNames(regNames))
        {*/

        writeRegisterFromMemoryMap(addressContainer, stream, memoryItem, false, targetInstance->getName());

        /*}
        else
        {
            writeRegisterFromMemoryMap(finder, memMap, stream, true, offset, interface->getComponentReference());
        }*/
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::memoryItemContainsAddressBlocks()
//-----------------------------------------------------------------------------
bool GlobalMemoryMapHeaderWriter::memoryItemContainsAddressBlocks(QSharedPointer<MemoryItem> memoryItem) const
{
    if (memoryItem->getChildItems().isEmpty() == false)
    {
        for (auto childItem : memoryItem->getChildItems())
        {
            if (childItem->getType() != MemoryDesignerConstants::ADDRESSBLOCK_TYPE)
            {
                return false;
            }
        }

        return true;
    }

    return false;
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseMirroredTargetInterface()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseMirroredTargetInterface(AddressContainer& addressContainer,
    QSharedPointer<const ConnectivityInterface> mirroredTargetInterface) const
{
    addressContainer.baseAddress_ += mirroredTargetInterface->getRemapAddress().toULongLong();

    auto newLastAddress = addressContainer.baseAddress_ + mirroredTargetInterface->getRemapRange().toULongLong();
    if (newLastAddress > 0)
    {
        newLastAddress = newLastAddress - 1;
    }

    if (addressContainer.hasRemapRange_ == false ||
        (addressContainer.hasRemapRange_ && newLastAddress < addressContainer.lastAddress_))
    {
        addressContainer.lastAddress_ = newLastAddress;
    }

    addressContainer.hasRemapRange_ = true;
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::displayMemoryMapHeader()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::displayMemoryMapHeader(QString const& filePath) const
{
    if (saveOptions_.isEmpty())
    {
        QDesktopServices::openUrl(QUrl::fromLocalFile(filePath));
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::checkConfigurableElementValues()
//-----------------------------------------------------------------------------
QSharedPointer<ListParameterFinder> GlobalMemoryMapHeaderWriter::createParameterFinder(QString const& instanceID,
    QSharedPointer<Component> component)
{
    QSharedPointer<QList<QSharedPointer<Parameter> > > configurableElementValues
        (new QList<QSharedPointer<Parameter> > ());

    QMap<QString, QString> configurableElementsInInstance;

    if (componentDesign_)
    {
        configurableElementsInInstance = getConfigurableElementsFromInstance(instanceID);
    }

    foreach (QSharedPointer<Parameter> parameterPointer, *component->getParameters())
    {
        QSharedPointer<Parameter> newConfigurableElement (new Parameter(*(parameterPointer)));

        if (configurableElementsInInstance.contains(newConfigurableElement->getValueId()))
        {
            newConfigurableElement->setValue(configurableElementsInInstance.value(
                newConfigurableElement->getValueId()));
        }

        configurableElementValues->append(newConfigurableElement);
    }

    QSharedPointer<ListParameterFinder> listFinder (new ListParameterFinder());
    listFinder->setParameterList(configurableElementValues);

    return listFinder;
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::getConfigurableElementsFromInstance()
//-----------------------------------------------------------------------------
QMap<QString, QString> GlobalMemoryMapHeaderWriter::getConfigurableElementsFromInstance(QString const& instanceId)
    const
{
    QMap<QString, QString> configurableElements;

    foreach (QSharedPointer<ComponentInstance> instance, *componentDesign_->getComponentInstances())
    {
        if (instance->getUuid() == instanceId)
        {
            foreach (QSharedPointer<ConfigurableElementValue> configurable,
                *instance->getConfigurableElementValues())
            {
                configurableElements.insert(configurable->getReferenceId(), configurable->getConfigurableValue());
            }

            break;
        }
    }

    return configurableElements;
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::getInstanceID()
//-----------------------------------------------------------------------------
QString GlobalMemoryMapHeaderWriter::getInstanceID(QString const& interfaceReference) const
{
    foreach (QSharedPointer<ComponentInstance> instance, *componentDesign_->getComponentInstances())
    {
        if (instance->getInstanceName() == interfaceReference)
        {
            return instance->getUuid();
        }
    }

    // This should not be reached.
    return QString();
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::getConnectedInterfaces()
//-----------------------------------------------------------------------------
QList<QSharedPointer<ActiveInterface> > GlobalMemoryMapHeaderWriter::getConnectedInterfaces(
    QSharedPointer<ActiveInterface> interface)
{
    QList<QSharedPointer<ActiveInterface> > connectedInterfaces;

    foreach (QSharedPointer<Interconnection> connection, *componentDesign_->getInterconnections())
    {
        if (connection->getStartInterface()->getComponentReference() == interface->getComponentReference() &&
            connection->getStartInterface()->getBusReference() == interface->getBusReference())
        {
            connectedInterfaces.append(*connection->getActiveInterfaces());
        }
        else
        {
            foreach (QSharedPointer<ActiveInterface> active, *connection->getActiveInterfaces())
            {
                if (active->getComponentReference() == interface->getComponentReference() &&
                    active->getBusReference() == interface->getBusReference())
                {
                    connectedInterfaces.append(connection->getStartInterface());
                }
            }
        }
    }

    return connectedInterfaces;
}
